# 进程关系

每个进程有个父进程（初始内核级进程通常是自己的父进程）。子进程终止，父进程得到通知并取得子进程退出状态。

进程组，回话，登录shell以及从登录shell启动的进程的关系，信号。

## 终端登录

早期UNIX系统，用户用哑终端（硬连接连到主机）进行登录。终端或者是本地的（直接连接）或者远程的（通过调制解调器连接）。登录经由内核中的终端驱动程序。

连到主机上的终端设备数是固定的，同时登录数有已知上限。

随着位映射图形终端的出现，开发出了窗口系统，为用户提供和主机系统交互的新方式。创建终端窗口的应用也被开发出来，通过shell命令行与主机交互。

### BSD终端登录

管理者创建/etc/ttys的文件，其中每个终端设备都有一行，每行说明设备名和传到getty程序的参数。

系统自举时，内核创建进程ID为1的进程，init进程。init使系统进入多用户模式，读取/etc/ttys，对每个允许登录的终端设备，init调用一次fork，子进程exec getty程序。

所以所有进程的实际用户ID和有效用户ID都是0，init以空环境exec getty程序。

getty对终端设备调用open函数，**读、写方式将终端打开**。若设备是调制解调器，则open可能会在设备驱动程序中滞留，直至用户拨号调制解调器，且线路被接通。

设备被打开，fd 0,1,2被设置到该设备。getty输出login：等待用户键入用户名，终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度（波特率）。

用户键入用户名后，getty工作完成，`execle("/bin/login", "login", "-p", username, (char *)0, envp);`调用login程序。init以空环境调用getty，getty以终端名和在gettytab中说明的环境字符串为login创建一个环境。 -p通知login保留传递给它的环境，可将其他环境字符串加入该环境但是不要替换。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-15-20-07-49-image.png)

init具有超级用户特权，所以fork的进程也有超级用户特权，9-2 底部3进程ID相同，进程ID不会因执行exec改变，除最开始的init，其余进程父进程ID均为1。

login能处理多项任务，能调用getpwnam取得相应用户的口令文件登录项。调用getpass，读用户键入的口令，禁止回显。 调用crypt，将用户键入口令加密并与该用户在阴影口令文件中登录项`pw_passwd`字段相比较。

如果用户几次键入口令都无效，则login exit(1)表示登录失败，父进程再次调用fork，执行getty重复上述过程。

应用程序需要验证用户是否具有权限执行服务，将身份验证机制编写入应用，或使用PAM库得到同样的功能。PAM优点在于基于本地策略、针对不同任务配置不同的验证用户身份方法

用户登录正确，login则：

1、将当前工作目录更改为该用户起始目录

2、调用chown更改该终端所有权，使登录用户成为它所有者

3、对该终端设备的访问权限改变成“用户读和写”

4、调用setgid及initgroups设置进程的组ID

5、用login得到的所有信息初始化环境：HOME SHELL USER LOGNAME PATH

6、login进程更改为登录用户的用户ID并调用该用户的登录shell。

实际上login程序可选择地打印日期消息文件、检查新邮件及执行其他一些任务。

执行完启动文件后，用户最后得到shell提示符才能键入命令。

### Mac OS X终端登录

类似BSD端，init工作为launched完成，一开始就是图形终端。

### Linux终端登录

类似BSD。login是BSD的login派生而来，区别在于说明终端配置的方式。

### Solaris终端登录

getty方式与BSD一样，用于控制台； ttymon登录用于其他终端的登录。

ttymon命令是服务访问设施的一部分。 init是sac父进程，sac调用fork，当系统进入多用户状态，其子进程执行ttymon程序，ttymon监控在配置文件中列出的所有终端端口，用户登录时，调用一次fork，之后ttymon的子进程调用login，而后执行登录用户的登录shell。shell父进程为ttymon。

## 网络登录

串行终端登录至系统和经由网络登录至系统两者间主要区别（物理上）：网络登录，终端和计算机之间连接不是点到点，login仅仅是一种可用服务，与其他网络服务（FTP或SMTP）性质相同。

网络登录都经由内核的网络接口驱动程序，且事先不知道会有多少这样的登录，因此必须等待一个网络连接请求的到达，而不是使一个**进程等待每一个可能的登录**。

为使同一个软件既能处理终端登录，又能处理网络登录，系统通过伪终端的软件驱动程序，仿串行终端运行行为，并将终端操作映射为网络操作。

### BSD网络登录

BSD中有inetd进程，因特网超级服务器，等待大多数网络连接，init调用shell并使其执行shell脚本/etc/rc，此shell脚本启动守护进程inetd。一旦此shell脚本终止，inetd父进程变成init。inetd等待TCP/IP连接请求到达主机，连接请求到达时，执行fork，子进程exec。

对于TELNET服务进程的TCP连接请求到达。客户端用户在主机启动TELNET客户进程，由此启动登录过程：

`telnet hostname`

客户进程打开一个到hostname主机的TCP连接，hostname主机上启动的TELNET服务进程，客户进程和服务进程间使用TELNET应用协议通过TCP连接交换数据。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-15-21-10-48-image.png)

telnetd进程打开一个为终端设备，fork分成两个进程，父进程处理网络连接通信，子进程执行login程序，父子进程通过伪终端相连接。伪终端设备驱动和实际终端用户间进行了很多工作，登录shell的标准输入、标准输出和标准错误要么连接到一个终端设备驱动，要么是伪终端设备驱动。

### Mac OS X网络登录

部分基于FreeBSD，telnet守护进程从launchd运行，更好办法使用ssh而非telnet

### Linux网络登录

有些版本使用扩展的因特网服务守护进程 xinetd代替inetd。对它所启动的各种服务控制更加精细。

### Solaris网络登录

与BSD和Linux步骤几乎一致，同样使用类似于BSD版的inetd服务进程，inetd服务进程在SMF作为restarter运行，restarter是守护进程，负责启动和监视其他守护进程，其他守护进程失败，restarter重启这些失效进程。

## 进程组

每个进程除了有进程ID，还属于一个进程组。

进程组是一个或多个进程的集合。通常在同一作业中结合，同一进程组各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID，可存放在`pid_t`数据类型。

```c
#include <unistd.h>
pid_t getpgrp(void);
//返回调用进程的进程组ID
```

返回调用进程的进程组ID，

```c
#include <unistd.h>
pid_t getpgid(pid_t pid);
//成功返回进程组ID，出错返回-1
```

pid为0，返回调用进程的进程组ID，getpgid(0) 等价于getpgrp()

每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。

进程组组长可以创建一个进程组、创建该组中进程，然后终止。进程组中有进程存在，则进程组存在，**与组长进程是否终止无关**。

进程组生命周期为进程组创建到组内最后一个进程离开。进程组中最后一个进程可以终止也可以转移到另一进程组。

```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
//成功返回0，出错返回-1
```

setpgid将pid的进程组ID设置为pgid。若两参数相等，则由pid指定的进程成为进程组组长。pid为0则使用调用者进程ID。pgid为0，pid指定进程ID为进程组ID。

一个进程只能为它自己或它子进程设置进程组ID，子进程调用exec后不能再更改其进程组ID。

大多数shell fork后使父进程设置子进程的进程组ID，使子进程设置自己的进程组ID，冗余设置保证父子进程认为该子进程进入该进程组前就发生了，否则次序不确定会产生竞争条件。

## 会话

session是一个或多个进程组的集合。通常由shell的管道将几个进程编为一组。

`proc1 | proc2 &` `proc3 | proc4 | proc5`

进程调用setsid函数建立一个新回话。

```c
#include <unistd.h>
pid_t setsid(void);
// 成功返回进程组ID，出错返回 -1
```

调用此函数的进程非进程组组长，则此函数创建一个新会话。

1、该进程变成新会话的会话首进程，session leader。该进程为新会话的唯一进程。

2、该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。

3、该进程没有控制终端。若在调用setsid前进程有控制终端，联系也被切断。

调用此函数的进程为进程组组长。此函数返回出错。为保证不处于该情况，通常先调用fork，使父进程终止，子进程继续。子进程继承父进程的进程组ID而子进程ID与进程组ID不可能相等。

SUS只说明了会话首进程，而没有会话ID，会话首进程是具有唯一进程ID 的单个进程，可以将其视为会话ID。

```c
#include <unistd.h>
pid_t getsid(pid_t pid);
//成功返回会话首进程的进程组ID，出错返回-1；
```

会话首进程进程组ID与进程ID一致。pid为0则返回调用进程的会话首进程的进程组ID。pid不属于调用者会话，则不能得到该会话首进程的进程组ID。

## 控制终端

会话和进程组的特性，

※一个会话可以有一个控制终端。通常是终端设备或伪终端设备。

※建立与控制终端连接的会话首进程被称为控制进程。

※一个会话中的几个进程组可被分成一个前台进程组以及一个或多个后台进程组。

※有控制终端的会话有一个前台进程组，其他进程组位后台进程组。

※无论何时键入终端的中断键，都会降中断信号发送至前台进程组所有进程。

※无论何时键入终端的退出键，都会将退出信号发送至前台进程组所有进程。

※终端接口检测到调制解调器或网络已经断开连接，则将挂断信号发送至控制进程。

通常登录时将自动建立控制终端。

会话首进程打开第一个尚未与一个会话相关联的终端设备时，只要在调用open时不指定`O_NOCTTY`，系统将此作为控制终端分配给此会话。

会话首进程使用TIOCSCTTY作为request参数调用ioctl，系统为会话分配控制终端。为使调用成功通常调用前使用setsid确保会话无控制终端。

不管标准输入和标准输出是否重定向，程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty.

若程序没控制终端，则对此设备open失败。

`crypt < salaries | lpr` 将salaries解密并打印缓冲服务。每次运行此程序都应输入加密口令。阻止用户将口令存放在文件中。

## 函数tcgetpgrp、tcsetpgrp和tcgetsid

```c
#include <unistd.h>
pid_t tcgetpgrp(int fd);
//成功返回前台进程组ID，出错返回-1
int tcsetpgrp(int fd, pid_t pgrpid);
//成功返回0，出错返回-1
```

通知内核前台进程组，使得终端输入和输出信号发送。

tcgetpgrp返回前台进程组ID，与fd上打开的终端关联。

若进程组有一个控制终端，进程可调用tcsetpgrp 设置前台进程组ID位pgrpid。 值为同一会话中的一个进程组ID。fd必须引用该会话的控制终端。

大多数应用进程不直接调用两函数，由作业控制shell调用。

```c
#include <unistd.h>
pid_t tcgetsid(int fd);
```

管理控制终端的应用程序调用tcgetsid识别控制终端的会话ID。

## 作业控制

允许在一个终端上启动多个作业（进程组），控制哪一个作业可以访问该终端以及哪些作业在后台允许。需要支持：

1、支持作业控制的shell。

2、内核中终端驱动程序必须支持作业控制。

3、内核必须提供对某些作业控制信号的支持。

从shell使用角度，用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合。通常是一个进程管道。

`vi main.c`前台启动了一个进程组成作业

`pr *.c | lpr &`

`make all &` 后台启动了两个作业。这两后台作业调用的所有进程都在后台运行。

shell不一定支持作业控制。

启动一个后台作业，shell赋予它一个作业标识符，并打印一个或多个进程ID。

键入影响前台作业的特殊字符，挂起键ctrl+Z，与终端驱动程序进行交互作用。SIGTSTP发送至前台进程组中所有进程，后台进程组作业则不受影响。

※中断字符 Delete或在Ctrl+C 产生SIGINT

※退出字符 Ctrl+\ 产生SIGQUIT

※挂起字符 Ctrl+Z 产生SIGTSTP

终端驱动程序必须处理与作业控制有关的另一种情况。一个前台作业，若干后台作业，哪一个接收终端键入字符。前台作业接收终端输入。后台作业试图读终端，终端驱动程序将发送SIGTTIN信号，停止此后台作业，shell向用户发出情况通知，用户可用shell将此作业转前台作业运行，就可读终端。

后台作业，shell fg将作业送入前台运行。

stty可以禁止后台作业输出到控制终端。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-16-15-58-07-image.png)

窗口终端可实现作业控制。

## shell执行程序

后台程序读控制终端，有作业控制时，终端驱动程序返回SIGTTIN信号，无作业控制则将后台程序的标准输入重定向到/dev/null。

后台程序打开/dev/tty 并读该控制终端。看情况，作业控制以较好的方式处理一个终端在多个进程间的转接。

Bourne shell中 管道最后一个进程为shell子进程，管道其他进程均为最后一个进程的子进程

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-16-16-25-59-image.png)

Linux shell中，ps命令是进程组组长进程，也是该进程组的唯一进程。

shell不同，创建进程顺序不同。

## 孤儿进程组

父进程终止的进程为孤儿进程，由init进程收养。

进程fork了子进程后终止。孤儿进程组定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。

在父进程终止后，进程组包含了一个停止进程，进程组成为孤儿进程组，要求向新孤儿进程组中处于停止状态的每个进程发送挂断信号SIGHUP，又发送SIGCONT信号。

案例中，父进程终止时子进程变成后台进程组。

## FreeBSD实现

进程、进程组、会话和控制终端的属性及实现。

session结构：会话中进程组数、指向会话首进程的proc结构的指针、指向控制终端的vnode结构指针、指向控制终端的tty结构的指针、会话ID。

调用setsid时，分配新session结构，其中count为1，leader为调用进程的proc结构指针，sid为进程ID。控制终端均为空指针。

tty结构，每个终端设备和每个伪终端设备均在内核中分配一种结构：指向将此终端作为控制终端的session结构，终端失去载波信号时使用此指针将挂起信号发送给会话首进程；指向前台进程组的pgrp结构；包含特殊字符和与该终端有个信息的结构；包含终端窗口的当前大小winsize型结构，窗口大小改变，SIGWINCH被发送至前台。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-16-17-17-31-image.png)

为找到特定会话的前台进程组，内核从session结构开始，用ttyp得到控制终端tty结构，用tpgrp得到前台进程组pgrp结构。

pgrp结构包含：进程组ID；指向此进程组所属会话的session结构；指向此进程组proc结构表的指针。proc中包含进程组成员，其中pglist为双向链表，指向该组上一个和下一个进程，直到遇到进程组最后一个进程，其pglist结构为空指针。

proc包含进程ID；指向父进程proc结构的指针；指向本进程所属进程组pgrp结构指针；双向链表

vnode结构，打开控制终端设备时分配此结构，对/dev/tty的所有访问都通过vnode结构。
