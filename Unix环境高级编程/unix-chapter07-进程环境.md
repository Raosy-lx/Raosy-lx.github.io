# 进程环境

进程控制原语，程序执行时，main函数如何被调用；命令行参数如何传递给新程序；典型存储空间布局；如何分配额外存储空间；进程使用环境变量；进程的各种不同终止方式；longjmp和setjmp函数及其与栈交互作用。进程的资源限制。

## main函数

`int main(int argc, char *argv[]);`函数原型，argc为命令行参数数目，argv为指向各参数的指针数组。

内核执行C程序时，使用exec函数，调用main前先调用特殊启动例程，可执行程序文件将此启动例程指定为程序起始地址（由C编译器调用的连接编译器设置。）启动例程从内核取得命令行参数和环境变量值，按上述方式调用main函数做好安排。

## 进程终止

8种终止方式，其中5种为正常终止：

1、从main返回

2、调用exit

3、调用`_exit`或者`_Exit`

4、最后一个线程从其启动例程返回

5、从最后一个线程调用`pthread_exit`

异常终止有三种

6、调用abort

7、接到一个信号

8、最后一个线程对取消请求做出响应。

启动例程以C代码形式`exit(main(argc, argv));`

### 退出函数

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);
```

`_exit`和`_Exit`立即进入内核，exit则先执行一些清理处理再返回内核。

exit函数总是执行标准I/O库清理关闭操作：对所有打开流调用fclose函数。

三个退出函数都带整型参数，称为终止状态，exit status。若（a）调用函数不带终止状态，（b）main执行了无返回值的return，（c）main没有声明返回类型为整型。则该进程终止状态未定义。若main返回类型为整型，并且执行到最后一条语句时返回，该进程状态为0

main函数返回一个整型值和用该值调用exit等价，即exit(0) 等价于return(0) ;

### 函数atexit

```c
#include <stdlib.h>
int atexit(void (*func)(void));
//成功返回0，出错返回非0
```

一个进程最多登记32个函数，函数通过exit自动调用，这些函数为终止处理程序，利用atexit函数来登记这些函数。

atexit参数为一个函数地址，调用此函数无需传递任何参数也不需返回值，exit调用函数顺序与登记顺序相反，同一函数多次登记也会被多次调用。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-12-14-01-58-image.png)

exit首先调用各终止处理程序再关闭打开流。内核使程序执行的唯一方法是调用exec函数，进程自愿终止唯一方法是显式或隐式（通过调用exit）调用`_exit或_Exit`。进程也可非自愿由信号终止。

## 命令行参数

执行程序时，调用exec的进程可将命令行参数传递给该新程序。 argv[argc]为NULL

## 环境表

每个程序都接收到一张环境表。一个字符指针数组。每个指针包含一个以null结束的C字符串地址，全局变量environ则包含了该指针数组的地址：

`extern char **environ`

environ为环境指针，各指针指向字符串为环境字符串。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-05-12-14-25-12-image.png)

name=value 环境字符串，大多数UNIX支持main带三个参数

`int main(int argc, char *argv[], char *envp[]);`

由于全局变量environ，所以不用第三个参数。使用getenv和putenv访问特定的环境变量，查看整个环境，必须使用environ。

## C程序的存储空间布局

C程序由5个部分组成：

1、正文段（代码段），CPU执行的机器指令部分。可共享，通常只读

2、初始化数据段。简称数据段，包含程序需明确地赋初值的变量，保存变量及其初值。

3、未初始化数据段，bss段，block started by symbol，由符号开始的块，程序执行前，内核将该段数据初始化为0或空指针。

4、栈，自动变量及每次函数调用时所需保存的信息，存放在此段中。每次函数调用时，其返回地址及调用者的环境信息（寄存器中的值）存放在栈中。最近被调用的函数在栈上为其自动和临时变量分配存储空间。递归每次调用自身则用新栈帧。栈从高地址向低地址分配。

5、堆，通常在堆中动态存储分配。通常堆位于栈和bss段间，堆从低地址向高地址分配。

bss段内容并不存放在磁盘程序文件中，内核在程序 开始运行前将它们置为0，存放在磁盘程序文件中的段只有正文段和初始化数据段。

size命令报告正文段、数据段、bss段长度（以字节为单位）dec和hec为十进制和十六进制的三段总长度。

## 共享库

大多数UNIX支持共享库，共享库使可执行文件不再需要包含公用的库函数，只需在所有进程都可引用的存储区中保存这个库例程的一个副本。

程序第一次执行或者第一次调用某库函数，以动态链接方法将程序和共享库函数相链接，**减少可执行文件的长度，增加运行时间开销**。时间开销在该程序第一次被执行，或每个共享库函数第一次被调用时。

共享库可以**用库函数新版本代替老版本而无需读使用该库程序重新连接编辑**（参数类型数目不变）

可以决定是否使用共享库。

## 存储空间分配

三个用于存储空间动态分配的函数 malloc calloc realloc

1、malloc 用于分配指定字节数的存储区，存储区初始值不确定

2、calloc，为指定数量指定长度的对象分配空间，该空间的每一位bit都初始化为0。

3、realloc，增加或减少以前分配区的长度。增加长度可能需将以前分配区的内容移到另一足够大的区域，新增区域内的初始值不确定。

```c
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);
//成功返回非空指针，出错返回NULL；
void free(void *ptr);
```

这三个分配函数返回的指针适当对齐，使其可用于任何数据对象。返回的通用指针void* ,将这些函数返回的指针赋予一个不同类型的指针时，不需要显式地执行强制类型转换。未声明函数的默认返回值为int。

没有正确函数声明的强制类型转换可能会隐藏系统错误，int长度和函数返回类型值长度不同

free释放ptr指向的存储空间。被释放的空间通常送入存储区池。

realloc用于增、减以前分配的存储区长度。如果存储区后有足够的空间供扩充，可在原存储区位置上向高地址方向扩充，无需移动原先内容，返回传给它的相同指针。否则，realloc分配另一足够大的存储区并将现存元素内容复制到新分配存储区。而后释放原存储区，返回新分配区的指针。该存储区会移动位置，不应使指针指向该区。

realloc的newsize为新存储区长度，ptr为空指针则realloc和malloc相同。

分配例程使用`sbrk`系统调用实现，系统调用扩充或缩小进程的堆。大多数malloc和free实现不减小进程的存储空间，释放后的空间保持在malloc池而不返回给内核供后续分配。

大多数实现所分配的存储空间比所要求的要稍大一些。额外空间用于记录管理信息（分配块的长度、指向下一个块的指针）。如果超过一个分配区尾端或在已分配区起始位置前写操作，会改写另一块管理记录。

在动态分配的缓冲区前后写，不仅可能破坏该区管理记录信息，可能破坏其他动态分配的对象。

释放一个已经释放的块；调用free所用指针不是alloc返回值等。 动态分配存储空间而不释放会造成内存泄露，存储空间连续增加。

每次使用3个分配函数中任意一个或free时，进行附加检错。

### 替代的存储空间分配程序

可替代malloc和free。

libmalloc库，提供存储空间分配函数相匹配的接口（mallopt，使进程可设置变量并用变量控制存储空间分配程序，mallinfo，对存储空间分配程序操作进行统计）

vmalloc，允许进程对不同存储区使用不同技术。

quick-fit， 快速适配算法，可能使用较多存储空间。基于将存储空间分裂成各种长度缓冲区，将未使用缓冲区按长度组成不同的空闲区列表。

jemalloc，库函数malloc族在FreeBSD中的实现。具有良好可扩展性，多处理器系统中使用多线程的应用程序。

TCMalloc，替代malloc函数族来提供高性能、高扩展性和高存储效率。从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中，使用线程-本地高速缓存来避免锁开销。 有内置堆检查程序和堆分析程序调试和分析动态存储的使用。

alloca， 调用序列与malloc相同，在当前函数栈帧上分配存储空间，而非堆内，优点在于函数返回自动释放栈帧，缺点在于alloca函数增加栈帧长度，不一定被支持。

## 环境变量

name = value  HOME = /...

shell使用大量环境变量，比如MAILPATH，告诉邮件查看地址。

```c
#include <stdlib.h>
char *getenv(const char *name);
//成功返回value，失败返回NULL
```

获取环境变量的值，返回value指针。

除了获取环境变量值，可能需要设置环境变量，改变或者增加环境变量（**这能影响当前进程及其后生成和调用的子进程环境**，修改环境表能力有限）

```c
#include <stdlib.h>
int putenv(char *str);
//成功0失败非0
int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
//成功返回0，失败-1
```

putenv取name=value形式字符串，name存在删除原定义。

setenv将name设置成value，name存在则rewrite非0才删除原定义。

unsetenv删除name定义，不存在该定义也不报错。

setenv需要分配存储空间创建name=value，而putenv不需要，但栈中字符串作为putenv输入报错，函数返回可能重用栈帧所用存储区。

环境表和环境字符串通常存放在进程存储空间的顶部（栈之上）。删除过程找到指针并将后续指针上移。增加字符串或修改现有字符串困难，进程地址空间不能向上高地址方向扩展，不能移动各栈帧，不能向下扩展，即空间长度不能增加。

修改name value长度小于等于现有value，复制新字符串到原字符串空间；value长度大于原长度，必须malloc分配空间，新字符串复制到该空间并改变环境表中指向name的指针

增加新name，必须先malloc分配空间，复制字符串到此空间。

第一次新增name，必须调用malloc为新指针表分配空间，并复制环境表到新分配去，将指向name=value指针存放在该表表尾，其后添加空指针，最后environ指向新指针表。

非第一次新增name，调用realloc，分配比原空间多存放一个指针的空间，将指向新name=value指针存在表位，其后添加空指针。

## 函数setjmp和longjmp

goto不能跨越函数，跳转需要setjmp和longjmp，对于处理发生在很深层嵌套函数调用中的出错情况非常有用。

深层嵌套的函数，其栈帧不断增加，某一函数出错，无需逐层返回。非局部goto，在栈上跳过若干帧，返回到当前函数调用路径上的某一个函数。

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
//直接调用返回0，从longjmp返回为非0；
void longjmp(jmp_buf env, int val);
```

在希望返回到的位置调用setjmp，env类型为`jmp_buf`，是某种形式数组，存放在调用longjmp时能用来恢复栈状态的所有信息，env通常全局变量。

检查到错误，使用longjmp，val为从setjmp返回的值，setjmp可能有多个longjmp，val可以判断造成longjmp的函数。

longjmp反绕执行main，此时val不为0报错。

### 自动变量、寄存器变量和易失变量

longjmp返回到main函数时，变量值能否回滚到原先值，看情况。

大多数不回滚这些自动变量和寄存器变量的值，若不想使其值回滚，定义其具有volatile属性。声明为全局变量或静态变量的值在执行longjmp时保持不变。

全局变量、静态变量和易失变量不受优化影响，longjmp后为最近呈现值。

autoval和寄存器变量优化后呈现调用setjmp的值，即寄存器中的值。

### 自动变量的潜在问题

声明自动变量的函数已经返回后，不能再引用这些自动变量

标准I/O库函数中，缓冲区应当为全局存储空间静态或动态变量。

## 函数getrlimit和setrlimit

每个进程有一组资源限制，可以更改

```c
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);
//成功返回0 失败非0
```

每一次调用都指定一个资源以及一个指向下列结构的指针。

```c
struct rlimit{
    rlim_t rlim_cur; //soft limit
    rlim_t rlim_max; //hard limit
}
```

更改资源限制遵循三点规则

1、任何进程可将软限制更改为小于等于硬限制

2、任何进程可降低其硬限制值，必须大于等于软限制值。降低对普通用户不可逆

3、超级用户进程可以提高硬限制值。

`RLIM_INFINITY`指定无限量限制。

资源限制影响到调用进程并由子进程继承。
