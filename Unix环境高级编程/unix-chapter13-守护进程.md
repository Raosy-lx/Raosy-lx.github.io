# 守护进程

生存期长的一种进程。通常在系统引导装入时启动，系统关闭时终止。后台运行。UNIX系统有很多守护进程，执行日常事务活动。

要点：守护进程结构、编写守护进程程序。守护进程如何报告出错。

## 守护进程的特征

系统进程依赖于操作系统实现，父进程ID为0的各进程通常是内核进程。

ps输出中，内核守护进程的名字出现在方括号。

需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有自己的内核守护进程。如Linux中：

1、kswapd守护进程称为内存换页守护进程。支持虚拟内存子系统在经过一段时间后将脏页面慢慢写回磁盘来回收这些页面。

2、flush守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘。也定期将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可同时存在，每个写回的设备都有一个冲洗守护进程。

3、sync_supers 守护进程定期将文件系统元数据冲洗至磁盘。

4、jbd守护进程帮助实现了ext4文件系统中的日志功能。

进程1通常是init（Mac OS X中是launchd），是系统守护进程，主要负责启动各运行层次特定的系统服务。服务通常在它们自己拥有的守护进程帮助下实现。

rpcbind守护进程提供将远程过程调用RPC程序号映射为网络端口号的服务。

rsyslogd守护进程可被由管理员启用的将系统消息记入日志的任何程序使用。可在实际的控制台上打印这些消息，也可将它们写到一个文件中。

inetd守护进程，侦听系统网络接口，来取得来自网络的对各种网络服务进程的请求。

nfsd、nfsiod、lockd、rpciod、rpc.idmapd、rpc.statd和rpc.mountd守护进程提供对网络文件系统的支持。 前四个是内核守护进程，后三个是用户级守护进程。

cron守护进程在定期安排的日期和时间执行命令。atd守护进程与cron类似，允许用户在指定的时间执行任务，但每个任务只执行一次，而非在定期安排的时间反复执行。cupsd守护进程是个打印假脱机进程，处理对系统提出的各个打印请求。sshd守护进程提供了安全的远程登录和执行设施。

大多数守护进程以root特权运行，所有守护进程**没有控制终端**。内核守护进程以无控制终端方式运行，而用户层守护进程则可能是守护进程调用了setsid的结果。

大多数用户层守护进程是进程组**组长进程**以及会话的**首进程**，且是这些进程组合会话中唯一进程。 **用户层守护进程的父进程是init进程**。

## 编程规则

编写守护进程程序需遵循一些基本规则

1、**调用umask**将文件模式创建屏蔽字设置为一个已知值（通常为0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限，守护进程要创建文件，则可能要设置特定的权限。

2、**调用fork，然后父进程exit**。若守护进程作为一条简单shell命令启动，父进程终止会让shell认为该命令执行完毕；子进程继承了父进程的进程组ID但获得了新的进程ID，即子进程并非进程组组长进程。

3、**调用setsid创建一个新会话**。使调用进程称为新会话的首进程，成为新进程组的组长进程，没有控制终端。

4、**将当前工作目录更改为根目录**。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。

守护进程通常在系统再引导之前一直存在，若守护进程当前工作目录在一个挂载文件系统中，则该文件系统不能被卸载。

某些守护进程会把当前工作目录更改到某个指定位置，完成其全部工作。行式打印机假脱机守护进程即是。

5、关闭不再需要的文件描述符。守护进程不再持有父进程继承来的任何fd。使用open_max，或getrlimit函数判定最高fd值，并关闭直到该值的所有fd。

6、某些守护进程打开/dev/null，使其具有文件描述符0、1、2，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生效果。守护进程并不与终端设备相关联，其输出无处显示也无法接收输入。

即使守护进程从交互式会话启动，但仍在后台运行，登录会话的终止不影响守护进程。

## 出错记录

守护进程处理出错消息存在问题。没有控制终端，不能简单地写到标准错误上。

不希望每个守护进程将它的出错消息写到控制台设备，因为很多工作站上控制台设备运行这一个窗口系统。

不希望每个守护进程将它的出错消息写到一个单独的文件中。给系统管理人员造成困难。

有一个集中的守护进程出错记录设施。BSD的syslog设施得到广泛应用。

![](C:\Users\asuss\AppData\Roaming\marktext\images\2021-06-03-22-19-55-image.png)

有三种产生日志消息的方法：

1、内核例程可以调用log函数，任何用户进程都可以通过打开并读取/dev/klog设备来读取这些消息。

2、大多数用户进程（守护进程）调用syslog函数来产生日志消息。这使消息被发送到UNIX域数据报套接字/dev/log

3、主机或者通过TCP/IP网络连接到此主机的其他主机上的用户进程，可将日志消息发向UDP端口514。syslog函数不产生UDP数据报，它们要求产生此日志消息的进程进行显式的网络编程。

syslogd守护进程读取所有3种格式的日志消息。在启动时读一个配置文件，文件名一般为/etc/syslog.conf，该文件决定了不同种类的消息应送向何处。紧急消息→管理员并在控制台上打印，警告消息→文件

```c
#include <syslog.h>
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
int setlogmask(int maskpri);
//返回 前日志记录优先级屏蔽字
```

openlog可选，不调用则在第一次调用syslog时自动调用openlog。 closelog也是可选，只是关闭曾被用于与syslogd守护进程进行通信的描述符。

ident将被加至每则日志消息中。ident一般是程序的名称（cron，inetd等）。option是指定各个选项的位屏蔽。

facility参数目的在于可以让配置文件说明，来自不同设施的消息将以不同的方式进行处理。

不调用openlog或以facility为0调用，则在调用syslog可将facility作为priority参数的一部分进行说明。

使用syslog产生一个日志消息。priority是facility和level的组合。level值为紧急→调试，优先级逐渐下降。

将format参数及其他所有参数传至vsprintf函数以便进行格式化，format中的 %m 字符被代换成与errno值对应的出错消息字符串。

setlogmask用于设置进程的记录优先级屏蔽字。返回调用前的屏蔽字，设置了记录优先级屏蔽字时，各条消息除非已在记录优先级屏蔽字中进行了设置，否则将不被记录。设置为0并没作用。

很多系统将logger程序作为向syslog设施发送日志消息的方法。logger专门为以非交互方式运行的需要产生日志消息的shell脚本设计。

除了syslog，很多平台提供它的一种变体来处理可变参数列表

```c
#include <syslog.h>
#include <stdarg.h>
void vsyslog(int priority, const char *format, va_list arg);
```

syslog大多数实现将使消息短时间处于队列中，此段时间有重复消息到达，不会写到日志记录中，而会打印输出一条“上一条重复了N次”的消息。

## 单实例守护进程

某些守护进程的实现为，在任一时刻只运行该守护进程的一个副本。如守护进程需排它地访问一个设备。对cron守护进程而言，同时运行多个实例，每个副本都可能试图开始某个预定的操作，造成该操作重复执行从而可能导致出错。

若守护进程需要访问一个设备，该设备驱动程序有时会阻止想要多次打开/dev目录下相应设备节点的尝试。这就限制了在一个时刻只能运行守护进程的一个副本。

文件和记录锁机制，保证单实例守护进程。

如果每个守护进程创建一个有固定名字的文件，并在该文件的整体上加一把写锁，则只允许创建一把这样的写锁。此后创建写锁失败，向后续的副本指明有一副本运行。

文件和记录锁提供了一种方便的互斥机制。守护进程在一个文件的整体上得到一把写锁，则该守护进程终止时，这把锁将被自动删除。简化了复原所需的处理，去除了对以前的守护进程实例需要进行清理的有关操作。

## 守护进程 daemon 的惯例

UNIX系统守护进程遵循通用惯例：

1、若守护进程使用锁文件，则该文件通常存储在/var/run目录中。可能守护进程需超级用户权限才能创建文件。锁文件名字通常是*name*.pid，*name*为该守护进程或服务的名字。cron守护进程锁文件的名字是/var/run/crond.pid

2、若守护进程支持配置选项，则配置文件通常存放在/etc目录中，配置文件的名字通常是*name*.conf，*name*为该守护进程或服务的名字。syslogd守护进程的配置文件/etc/syslog.conf

3、守护进程可用命令行启动，通常它们是由系统初始化脚本之一（`/etc/rc*`或`/etc/init.d/*`）启动的。如果在守护进程终止时，应当自动地重启它，则我们可在/etc/inittab中为该守护进程包括respawn记录项，init就将重新启动该守护进程。

4、若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，在此之后一般不会再查看它。某个管理员更改了配置文件，则守护进程可能需要被停止，再启动，使配置文件更改生效。某些守护进程捕捉SIGHUP信号，接收到则重新读配置文件。守护进程不与终端相结合，它们或者是无控制终端的会话首进程，或者是孤儿进程组的成员，所以守护进程不期望接收SIGHUP，即可以安全地重复使用SIGHUP。

## 客户进程-服务器进程模型

守护进程常常用作服务器进程。syslogd可被称为服务器进程，用户进程用UNIX域数据报套接字向其发送消息。

服务器进程等待客户进程与其联系，提出某种类型的服务要求。syslogd提供的服务是将一条出错消息记录到日志文件中。

客户进程向服务器进程发送请求，服务器进程向客户进程回送应答。

服务器进程调用fork然后exec另一个程序来向客户进程提供服务是很常见的。通常服务器进程管理多个fd：通信端点、配置文件、日志文件和类似的文件。最好情况下，**子进程中这些fd保持打开状态无碍**，因为很可能不会被子进程执行程序使用，尤其是与服务端无关的程序。最坏情况，保持打开会导致安全问题，被执行程序由恶意行为，如更改服务端配置文件或欺骗客户端程序使其认为正在与服务器端通信而获取未授权信息。

通过对所有被执行程序不需要的文件描述符设置执行时关闭标志可以用于解决此问题。
